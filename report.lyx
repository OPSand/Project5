#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Project 5, FYS 3150 / 4150, fall 2013
\end_layout

\begin_layout Author
Student #
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Open clusters are groups of up to a few thousands stars, held together by
 mutual gravitational attraction.
 Open clusters generally last for a few hundred milions years.
 In it also important to underline that the parameters of the cluster's
 particles are kind of constant, since they are made from the same material.
 We want to build a model for such a cluster, and study its 
\begin_inset Quotes eld
\end_inset

cold collapse
\begin_inset Quotes erd
\end_inset

, i.e.
 its .
 To do so, we will begin with the approximation that stars are particles,
 ponctual points, then we will use a simple smoothing algorithm to increase
 the numerical stability of our system.
\end_layout

\begin_layout Standard
Numerous algorithms could have been used to simulate the behavior of the
 cluster.
 We chose to focus on the Leap-frog and on the forth-order Runge Kutta ones.:if
 each one of the numeric methods has its pros and cons, we want here to
 find the one which gives priority to the stability instead of the short-term
 accuracy.
 Indeed, due to the number of particles in our cluster, we will be interested
 in the statistical properties of our system instead of in the specific
 characteristics of each particles.
\end_layout

\begin_layout Standard
Our goal in this report is to simulate and to study the behavior of a cluster,
 after having paid attention to the algorithm used to derive the results.
 Thus, the first part of the report will be a discussion on the algorithms,
 and on the methods we implemented to help us, then, we will talk about
 the cluster's behavior itself.
\end_layout

\begin_layout Section
Theory
\end_layout

\begin_layout Subsection
Derivation of the expression for 
\begin_inset Formula $\tau_{crunch}$
\end_inset


\end_layout

\begin_layout Standard
Start with Elgarøy's notes (where 
\begin_inset Formula $t=0$
\end_inset

 at the Big Bang singularity for our sub-universe) and get
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
R(\psi)=a(\psi)R_{0}=\frac{R_{0}\Omega_{m0}}{2(\Omega_{m0}-1)}(1-\cos\psi)
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $a(\psi)$
\end_inset

 is the dimensionless scale factor and
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
t(\psi)=\frac{\Omega_{m0}}{2H_{0}(\Omega_{m0}-1)^{3/2}}(\psi-\sin\psi).
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
From these results we see that 
\begin_inset Formula $t_{max}=t(\psi=\pi)$
\end_inset

 and 
\begin_inset Formula $t_{crunch}=t(\psi=2\pi),$
\end_inset

 thus the elapsed time between these events is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\tau_{crunch}=t_{crunch}-t_{max}=\frac{\pi\Omega_{m0}}{2H_{0}(\Omega_{m0}-1)^{3/2}}.
\]

\end_inset


\end_layout

\begin_layout Standard
The mass parameter is defined by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Omega_{m0}=\frac{8\pi G\rho_{0}}{3H_{0}^{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
and for readability we will make the substitution
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
u^{2}=8\pi G\rho_{0}-3H_{0}^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
thus
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(\Omega_{m0}-1)^{-3/2}=(\frac{u^{2}}{3H_{0}^{2}})^{-3/2}=3\sqrt{3}H_{0}^{3}u^{-3}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\Omega_{m0}}{(\Omega_{m0}-1)^{3/2}}=\frac{8\pi G\rho_{0}}{3H_{0}^{2}}3\sqrt{3}H_{0}^{3}u^{-3}=8\sqrt{3}\pi G\rho_{0}H_{0}u^{-3}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\tau_{crunch}=\frac{\pi}{2H_{0}}8\sqrt{3}\pi G\rho_{0}H_{0}u^{-3}=4\sqrt{3}\pi^{2}G\rho_{0}u^{-3}
\]

\end_inset


\end_layout

\begin_layout Standard
Now we remember that at the time when 
\begin_inset Formula $\rho=\rho_{0},$
\end_inset

 everything is at rest, so we have 
\begin_inset Formula $H_{0}=(\frac{\dot{a}}{a})_{\tau=0}=0$
\end_inset

.
 Inserting this, we get 
\begin_inset Formula $u^{2}=8\pi G\rho_{0}$
\end_inset

, and
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\tau_{crunch}=4\sqrt{3}\pi^{2}G\rho_{0}(8\pi G\rho_{0})^{-3/2}=\sqrt{\frac{4^{2}3\pi^{4}G^{2}\rho_{0}^{2}}{8^{3}\pi^{3}G^{3}\rho_{0}^{3}}}=\sqrt{\frac{3\pi}{32G\rho_{0}}}\label{eq:tcrunch}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
which is what we wanted to show.
\end_layout

\begin_layout Subsection
Lack of a singularity in our model
\end_layout

\begin_layout Standard
TODO: Use Elgarøy II and Peacock as sources.
\end_layout

\begin_layout Standard
The reason we do not see a singularity in our model is that we have assumed
 pressureless (i.e.
 collisionless) matter in the Friedmann equations.
 In our simulation we will see internal pressure as kinetic energy from
 the collapse is turned into random motions by near-collisions between particles.
 This will act as a kind of pressure in our simulation and will halt the
 collapse, causing the gravitationally bound particles to form more or less
 stable orbits around the center of mass.
 Keep in mind that the kinetic energy is not evenly distributed, so occasionally
 particles that receive more than their fair share will become unbound and
 may escape from the system before they have time to lose their energy.
 (SOURCE: Given) predicts that this should happen to roughly ?? % of the
 particles.
 (TODO: rewrite?)
\end_layout

\begin_layout Standard
We say that the system is stable when the virial theorem
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
2\left\langle K\right\rangle =-\left\langle P\right\rangle 
\]

\end_inset

where 
\begin_inset Formula $\left\langle P\right\rangle $
\end_inset

 and 
\begin_inset Formula $\left\langle K\right\rangle $
\end_inset

 are the averages of the potential and kinetic energies (actually, these
 are supposed to be time averages for the total energies of the entire system,
 but it turns out that the averages of a point in time of the energies per
 particle is a good approximation to this (SOURCE).
 (SOURCE: Elgarøy II) shows that his happens at time 
\begin_inset Formula $\tau_{vir}=0.81\tau_{crunch}$
\end_inset

 when the sphere has collapsed to half its initial size, so we see that
 
\begin_inset Formula $\tau_{crunch}$
\end_inset

 is a natural time scale for virialization to occur (some sources do in
 fact use 
\begin_inset Formula $\tau_{crunch}$
\end_inset

 to mark the point when the system is virialized).
 
\end_layout

\begin_layout Subsection
\begin_inset Formula $G$
\end_inset

 in units of ly, 
\begin_inset Formula $M_{\sun}$
\end_inset

 and 
\begin_inset Formula $\tau_{crunch}$
\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $\tau_{crunch}$
\end_inset

 given in years, we can rewrite equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:tcrunch"

\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
G_{yr}=\frac{3\pi}{32\tau_{crunch}^{2}\rho_{0}}.
\]

\end_inset


\end_layout

\begin_layout Standard
Switching time units to 
\begin_inset Formula $\tau_{crunch}$
\end_inset

, we get that 
\begin_inset Formula $\tau_{crunch}=1$
\end_inset

 in these units, hence
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
G=\frac{3\pi}{32\rho_{0}}=\frac{\pi^{2}R_{0}^{3}}{8\mu N}\label{eq:G}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where for the latter equality we have used the definitions of average mass
 
\begin_inset Formula $\mu=\frac{M}{N}$
\end_inset

 and initial mass density for a sphere 
\begin_inset Formula $\rho_{0}=\frac{M}{V_{0}}=\frac{\mu N}{V_{n}(R_{0})}$
\end_inset

, where 
\begin_inset Formula $V_{n}(R_{o})$
\end_inset

 is the volume of the n-dimensional ball with radius 
\begin_inset Formula $R_{0}.$
\end_inset


\end_layout

\begin_layout Standard
This means our gravitational constant and our time unit both depend on 
\begin_inset Formula $N$
\end_inset

, 
\begin_inset Formula $R_{o}$
\end_inset

 and 
\begin_inset Formula $\mu$
\end_inset

.
 We can verify that the units for 
\begin_inset Formula $G$
\end_inset

 are now correct with 
\begin_inset Formula $R_{0}$
\end_inset

 given in light years and 
\begin_inset Formula $\mu$
\end_inset

 given in solar masses.
\end_layout

\begin_layout Subsection
Calculating 
\begin_inset Formula $\epsilon$
\end_inset

 automatically
\end_layout

\begin_layout Standard
The challenge with the 
\begin_inset Formula $\epsilon$
\end_inset

 values is that we want it to be as small as possible (to give more realistic
 results), yet make the number of ejected particles as small as possible,
 conserving as much of the total energy as we can.
 We chose to determine a good fit for 
\begin_inset Formula $\epsilon$
\end_inset

 experimentally (see TODO: FIGURE), and then we determined how this value
 would scale to different simulations in the following way:
\end_layout

\begin_layout Standard
The basic premise is that when 
\begin_inset Formula $r=\epsilon$
\end_inset

 (i.e.
 when the 
\begin_inset Formula $\epsilon$
\end_inset

 term starts dominating the gravitational potential), we want to set an
 upper limit on how much a particle's velocity can change during one time
 step due to the gravitational attraction from one other particle.
 We want this upper limit to be invariant across simulations:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\Delta v_{1}=\Delta v_{2}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a_{1}\Delta t_{1}=a_{2}\Delta t_{2}
\]

\end_inset


\end_layout

\begin_layout Standard
We will assume all particles have the average mass 
\begin_inset Formula $\mu$
\end_inset

 and set 
\begin_inset Formula $r=\epsilon$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{G_{1}\mu_{1}\Delta t_{1}}{2\epsilon_{1}^{2}}=\frac{G_{2}\mu_{2}\Delta t_{2}}{2\epsilon_{2}^{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
Now, inserting the value of 
\begin_inset Formula $G$
\end_inset

 from 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:G"

\end_inset

 with initial radii 
\begin_inset Formula $R_{1}$
\end_inset

 and 
\begin_inset Formula $R_{2}$
\end_inset

, we get:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\pi^{2}R_{1}^{3}\mu_{1}\Delta t_{1}}{2\epsilon_{1}^{2}\cdot8\mu_{1}N_{1}}=\frac{\pi^{2}R_{2}^{3}\mu_{2}\Delta t_{2}}{2\epsilon_{2}^{2}\cdot8\mu_{2}N_{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{R_{1}^{3}\Delta t_{1}}{\epsilon_{1}^{2}N_{1}}=\frac{R_{2}^{3}\Delta t_{2}}{\epsilon_{2}^{2}N_{2}}
\]

\end_inset


\end_layout

\begin_layout Standard
giving us this handy formula for 
\begin_inset Formula $\epsilon_{2}$
\end_inset

 if we have a good match for 
\begin_inset Formula $\epsilon_{1}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\epsilon_{2}=\sqrt{\frac{N_{1}}{N_{2}}\left(\frac{R_{2}}{R_{1}}\right)^{3}\frac{\Delta t_{2}}{\Delta t_{1}}}\cdot\epsilon_{1}\label{eq:epsilon}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
Gravitational potential with modified gravity
\end_layout

\begin_layout Standard
Starting with the magnitude of the force
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
F=\frac{GMm}{r^{2}+\epsilon^{2}}=\frac{GMm}{\epsilon^{2}}\frac{1}{(\frac{r}{\epsilon})^{2}+1}=\frac{GMm}{\epsilon^{2}}\frac{1}{u^{2}+1}
\]

\end_inset


\end_layout

\begin_layout Standard
where we have used the subsitution 
\begin_inset Formula $u=\frac{r}{\epsilon}$
\end_inset

 which gives 
\begin_inset Formula $\frac{du}{dr}=\frac{1}{\epsilon}$
\end_inset

, hence 
\begin_inset Formula $dr=\epsilon\cdot du$
\end_inset

, and so
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
E_{p}=m\Phi=\int Fdr=\frac{GMm}{\epsilon^{2}}\int\frac{1}{u^{2}+1}\epsilon du=\frac{GMm}{\epsilon}(\arctan(u)+C)
\]

\end_inset


\end_layout

\begin_layout Standard
We want 
\begin_inset Formula $E_{p}\rightarrow0$
\end_inset

 as 
\begin_inset Formula $r\rightarrow\infty$
\end_inset

, and since 
\begin_inset Formula $\arctan(u)\rightarrow\frac{\pi}{2}$
\end_inset

 as 
\begin_inset Formula $u\rightarrow\infty$
\end_inset

, we achieve this by choosing 
\begin_inset Formula $C=-\frac{\pi}{2}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
E_{p}=\frac{GMm}{\epsilon}(\arctan(\frac{r}{\epsilon})-\frac{\pi}{2})\qquad(\epsilon>0)
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
Volume of the n-ball
\end_layout

\begin_layout Standard
To calculate the gravitational constant with 
\begin_inset Formula $\tau_{crunch}$
\end_inset

 as the time unit in any dimension, we need the volume of the sphere in
 
\begin_inset Formula $n$
\end_inset

 dimensions to calculate the initial mean density 
\begin_inset Formula $\rho_{0}.$
\end_inset

 This is accomplished by the following formula:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
V_{n}=\frac{\pi^{\frac{n}{2}}}{\Gamma(\frac{n}{2}+1)}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
(Source.)
\end_layout

\begin_layout Subsection
Uniform distribution in the n-ball
\end_layout

\begin_layout Standard
Our dimension-independent algorithm for generating uniformly distributed
 points inside the n-ball is:
\end_layout

\begin_layout Enumerate
Generate random points on the surface of the unit n-ball (i.e.
 randomize the directions of the unit vectors):
\end_layout

\begin_deeper
\begin_layout Enumerate
Generate normally distributed n-dimensional vector 
\begin_inset Formula $\mathbf{x}_{n}=\left[x_{1},x_{2},\dots,x_{n}\right]$
\end_inset

 where the normal distribution has 
\begin_inset Formula $\mu=0$
\end_inset

 and 
\begin_inset Formula $\sigma=1$
\end_inset

.
\end_layout

\begin_layout Enumerate
Calculate the n-dimensional norm of the vector 
\begin_inset Formula $|\mathbf{x}_{n}|$
\end_inset

.
 We chose to let Armadillo handle this, but another easy way to do it is
 using the n-dimensional dot product and taking the square root of this:
 
\begin_inset Formula $|\mathbf{x}_{n}|=\sqrt{\mathbf{x}_{n}\cdot\mathbf{x}_{n}}=\sqrt{\sum_{i}x_{i}^{2}}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Turn it into a unit vector: 
\begin_inset Formula $\mathbf{u}_{n}=\frac{\mathbf{x}_{n}}{|\mathbf{x}_{n}|}$
\end_inset

.
 We refer to (source) for the proof that this is uniformly distriuted in
 terms of direction.
\end_layout

\end_deeper
\begin_layout Enumerate
Generate a radius that results in a uniform distribution within maximum
 radius 
\begin_inset Formula $R_{0}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Generate a uniformly distributed value 
\begin_inset Formula $r\in[0,1]$
\end_inset

.
\end_layout

\begin_layout Enumerate
The desired radius that takes into account that the outer spherical shells
 have a larger surface area is 
\begin_inset Formula $R=\sqrt[n]{r}\cdot R_{0}$
\end_inset

, where 
\begin_inset Formula $n$
\end_inset

 is the number of dimensions.
\end_layout

\end_deeper
\begin_layout Standard
(Source.)
\end_layout

\begin_layout Subsection
Algorithms
\end_layout

\begin_layout Standard
For both of our algorithms, the step intervalle looks like 
\begin_inset Formula $[t_{0};t_{max}]$
\end_inset

.
 We will work on 
\begin_inset Formula $n_{Steps}$
\end_inset

.
 Let's define h as 
\begin_inset Formula $h=\frac{t_{max}-t_{0}}{n_{Steps}-1}$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Runge-Kutta
\end_layout

\begin_layout Standard
We have
\begin_inset Formula $t_{i}=t_{0}+i.h\text{ for each i belonging to \ensuremath{{\displaystyle [0,n_{Steps}].}}}$
\end_inset

 We can now define 
\begin_inset Formula $x_{i}=x(t_{i})$
\end_inset

.
\end_layout

\begin_layout Standard
The general formulae of Simpson's rule is: 
\begin_inset Formula $\intop_{t_{i}}^{t_{i}+1}f(t,x)dt=\frac{1}{6}h(f(t_{i},x_{i})+2f(t_{i+\frac{1}{2}},x_{i+\frac{1}{2}})+f(t_{i+1},x_{i+1}))$
\end_inset

.
 
\end_layout

\begin_layout Standard
Runge-Kutta's method defines four quantities, to predict and correct the
 value of 
\begin_inset Formula $x_{i+1}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
k_{1}=f(t_{i},x_{i})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
k_{2}=f(t_{i+\frac{1}{2}},x_{i+\frac{1}{2}})\qquad x_{i+\frac{1}{2}}=x_{i}+\frac{h}{2}k_{1}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
k_{3}=f(t_{i+\frac{1}{2}},x_{i+\frac{1}{2}}^{^{*}})\qquad y_{i+\frac{1}{2}}=x_{i}+\frac{h}{2}k_{2}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
k4=f(t_{i+1},x_{i+1})\qquad x_{i+1}=x_{i}+hk_{3}
\]

\end_inset


\end_layout

\begin_layout Standard
In our case, we will have to compute this results six times by time step:
 once for the x,y and z positions, and once for the x,y and z velocities.
 
\end_layout

\begin_layout Standard
This Runge-Kutta algorithm is especially interesting since we only need
 initial conditions to unfold it.
 Its approximation error runs like 
\begin_inset Formula $\mathcal{O}(\Delta h^{2})$
\end_inset

 .
\end_layout

\begin_layout Subsubsection
Leapfrog algorithm
\end_layout

\begin_layout Standard
The Leapfrog algorithm is given by the trhee following steps:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x^{(1)}(t+\frac{h}{2})=(x^{(1)}(t)+\frac{h}{2}*x^{(2)}(t)+\mathcal{O}(\Delta h^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x(t+h)=x(t)+x^{(1)}(t+\frac{h}{2})+\mathcal{O}(\Delta h^{3})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x^{(1)}(t+h)=x^{(1)}(t+\frac{h}{2})+\frac{h}{2}*x^{(2)}(t+h)+\mathcal{O}(\Delta h^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
Now, let's take a look at the approximation error for this algorithm.
 The first step to derive this algorithm is to use Taylor expansion on the
 position:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x(t+h)=x(t)+hx^{(1)}(t)+\frac{h^{2}}{2}x^{(2)}(t)+\mathcal{O}(\Delta h^{3})=x(t)+h(x^{(1)}(t)+\frac{h}{2}*x^{(2)}(t))+\mathcal{O}(\Delta h^{3})
\]

\end_inset


\end_layout

\begin_layout Standard
In the same way, we have for the velocity:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x^{(1)}(t+\frac{h}{2})=x^{(1)}(t)+\frac{h}{2}*x^{(2)}(t)+\mathcal{O}(\Delta h^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x^{(1)}(t-\frac{h}{2})=x^{(1)}(t)-\frac{h}{2}*x^{(2)}(t)+\mathcal{O}(\Delta h^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x^{(1)}(t+\frac{h}{2})-x^{(1)}(t-\frac{h}{2})=x^{(1)}(t)+\frac{h}{2}*x^{(2)}(t)+\mathcal{O}(\Delta h^{2})-(x^{(1)}(t)-\frac{h}{2}*x^{(2)}(t)+\mathcal{O}(\Delta h^{2}))=h*x^{(2)}(t)+\mathcal{O}(\Delta h^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
So
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x^{(1)}(t+h)=x^{(1)}(t+\frac{h}{2})+\frac{h}{2}*x^{(2)}(t+h)+\mathcal{O}(\Delta h^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
We can rewrite the first step thanks to the expression of 
\begin_inset Formula $x^{(1)}(t+\frac{h}{2})$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
x(t+h)=x(t)+x^{(1)}(t+\frac{h}{2})+\mathcal{O}(\Delta h^{3})
\]

\end_inset


\end_layout

\begin_layout Standard
In the end, we can see that the approximation error runs like 
\begin_inset Formula $\mathcal{O}(\Delta h^{2})$
\end_inset

 for the Leapfrog algorithm.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
The code is designed to be highly modular and independent of dimension to
 maximise reusability.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename Screen/ClassDiagram.jpg
	scale 80

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Class Diagram
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SolarSystem class
\end_layout

\begin_layout Standard
Container class for the entire N-body system.
 This class is dimension independent (number of dimensions is given as a
 parameter), to make it as general and reusable as possible.
 Does not specify a method to solve the equations of motion, so any numerical
 method can be used on this class to update the positions every time step
 (by iterating over the celestial bodies contained in this class).
 A SolarSystem can make deep copies of itself (and all its CelestialBody
 and Gravity objects), which we make use of to be able to run different
 algorithms on identical copies of a system (for comparison of results and
 stability analysis).
\end_layout

\begin_layout Subsection
CelestialBody class
\end_layout

\begin_layout Standard
Particle class of our N-body simulation, with position and mass.
 Handles all calculations on the individual particle level (e.g.
 kinetic energy) and can be set to fixed if desired.
 Also stores properties calculated by the encompassing SolarSystem (like
 potential energy) so these will not have to be calculated on the fly every
 time they are needed.
 This class inherits dimensionality from the SolarSystem it belongs to,
 so we avoid creating a sub-dimensional celestial body by accident.
\end_layout

\begin_layout Subsection
Gravity class
\end_layout

\begin_layout Standard
This class allows each SolarSystem to use a different gravity.
 One can change both the value of the gravitational constant to fit the
 time unit of choice and set an 
\begin_inset Formula $\epsilon$
\end_inset

 value to dampen collisions.
 For future use it is possible to extend this class to include any form
 of modified gravity (which is of interest in cosmology, SOURCE).
 The only thing the SolarSystem class requires of this object is that it
 is able to return a force and potential energy when two CelestialBody objects
 are given as input.
 This way, a SolarSystem does not need to handle the specifics of gravitational
 forces itself, making the code more modular.
\end_layout

\begin_layout Subsection
CelestialBodyInitializer class
\end_layout

\begin_layout Standard
Sets up a uniform position distribution given an initial max radius (generalized
 for any number of dimensions).
 Also generates normal distributed random masses.
 Doing this in a separate class allows the SolarSystem class to be as general
 as possible (we might not want a random distribution every time, but when
 we do, this class will do the job).
 Keeping this class dimension independent makes it more general and easier
 to use in other projects.
\end_layout

\begin_layout Subsection
Solvers class
\end_layout

\begin_layout Standard
Contains code to iterate over a SolarSystem object over a number of time
 steps, using the Leapfrog, Runge-Kutta (4th order) and Euler-Cromer algorithms
 to solve the equations of motion.
 Creates copies of the system given as a parameter to do this, so we can
 keep the original system unchanged and also solve using several numerical
 methods simultaneously and compare the results.
 Keeping this in a separate class allows adaptation of this code to use
 other objects than the SolarSystems we employ here.
\end_layout

\begin_layout Subsection
GaussPDF class
\end_layout

\begin_layout Standard
This is simply a static class wrapper for the code given at:
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "https://www.uio.no/studier/emner/matnat/fys/FYS3150/h13/gaussiandeviate.cpp"
target "https://www.uio.no/studier/emner/matnat/fys/FYS3150/h13/gaussiandeviate.cpp"

\end_inset


\end_layout

\begin_layout Standard
It provides random numbers in the uniform and normal probability distributions.
\end_layout

\begin_layout Section
Results and analysis
\end_layout

\begin_layout Subsection
Benchmarks and validation
\end_layout

\begin_layout Paragraph*
Validation:
\end_layout

\begin_layout Standard
We worked during a previous project on the implementation of the Runge Kutta
 algorithm to simulate the behavior of the Solar System.
 To test our code, we also wrote the Euler-Cromer algorithm.
 The outputs of our previous project were validated.
 In order to testify that our code works, we tested it against our previous
 results, in two dimensions, then we extended it in three dimensions.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename Screen/BenchMark/plot2D_for_leapfrog.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Simulation with our Leapfrog algorithm
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename Screen/BenchMark/plot2D_for_rk4.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Simulation with our Runge Kutta - 4 algorithm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Screen/BenchMark/Orbite_Earth_Circu.png
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Simulation of our previous project
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We found equivalent results between the two projects, for the same time
 step size, one point per day, and the same length of simulation, two years,
 which lead us to says that our current code is working.
 
\end_layout

\begin_layout Standard
When we use them for very long times, we can see that the Leapfrog algorithm
 is way more well-behaved than the Runge Kutta one.
 Thus, we can say that the Runge Kutta algorithm is not as stable as the
 Leapfrog one for when being processed for long times
\end_layout

\begin_layout Standard
We saw in the theory part that the forth-order Runge Kutta has an approximation
 error smaller than the Leapfrog algorithm.
 It basically means that the local data about each particles will be more
 accurate but since the Leapfrog method is more stable than the Runge Kutta
 method, and gives satisfying results for small enough time steps.
 The Runge Kutta method is more accurate to compute the velocity, but here,
 it does not matter so much.
 It is also important to underline the fact that the Runge Kutta method
 generates an oscillation on the energy, while the energy is stable with
 the Leapfrog one.
 And if the time step gets to big, for both of our algorithm, everything
 becomes messy, and not usable.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Execution time (s)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
For 1000 steps, two bodies
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
For 1000 steps, 100 bodies
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Leap-frog
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19,18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86,35
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Forth-order Runge Kutta 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30,85
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
171,25
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Elapsed Time to process the two body system 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see here that the Runge Kutta algorithm takes more time to process
 the same set of data than the Leapfrog.
 For small data set, the time spent by the forth order Runge Kutta algorithm
 is twice as much as the time spent by the Leapfrog method.
 And when we increase the number of steps, or the number of bodies, we increase
 the time spent during processing.
 Thus, the difference in the execution time between Runge Kutta and Leapfrog
 becomes more and more significant.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Screen/BenchMark/plot3D_for_leapfrog.jpeg
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Conservation of the Energy -- Leap-frog -- Length = 2 years ~
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "20col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Screen/BenchMark/BM-Energy-LeapFrog.jpg
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Conservation of the Energy -- Leap-frog
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Screen/BenchMark/plot3D_for_rk4.jpeg
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Conservation of the energy -- forth-order Runge Kutta = Length = 2 years
 ~
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "20col%"
special "none"
height "1in"
height_special "totalheight"
status collapsed

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename Screen/Should probably be erased_not sure yet/CropperCapture[1].jpg
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Conservation of the energy -- forth-order Runge Kutta -- A changer !!!
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Application to a multi-bodies system
\end_layout

\begin_layout Subsubsection
Evaluation of 
\begin_inset Formula $G$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Screen/b/Eval_G_Resized.jpg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Computation of G
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
With a system of 
\begin_inset Formula $N=100$
\end_inset

 particles, an initial radius of 
\begin_inset Formula $R_{0}=20$
\end_inset

 light years, we found a 
\begin_inset Formula $\tau_{crunch}$
\end_inset

 of nearly 8 millions of years.
 In the figure above, the variable called G_YLS is the gravitational constant,
 uses meters, seconds, and kg.
 G is computed in ly, 
\begin_inset Formula $M_{\sun}$
\end_inset

 and 
\begin_inset Formula $\tau_{crunch}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $\tau_{crunch}$
\end_inset

 is evaluated in millions of years, thus, its unit could be the megaannum
 (i.e.
 the unit for 1,000,000 years).
\end_layout

\begin_layout Subsubsection
Choice of the algorithm
\end_layout

\begin_layout Standard
We will look for a satisfying time step.To do so, we will look at the total
 energy conservation over different time steps, for our two algorithms.
 Our system is the following: 100 particles, and an initial radius of 20
 light years.
 
\end_layout

\begin_layout Standard
According to the time required to process equivalent results, the Leapfrog
 algorithm seems more interesting.
 Furthermore, we are going now to process on a N-body system, where N is
 at least equal to 100.
 Thus, we will be more interested in the statistical properties of our system,
 than in the local accuracy of the position or the velocity.
\end_layout

\begin_layout Subsubsection
Energy conservation (finding a reference value for 
\begin_inset Formula $\epsilon$
\end_inset

)
\end_layout

\begin_layout Standard
With a system of 
\begin_inset Formula $N=100$
\end_inset

 particles, an initial radius of 
\begin_inset Formula $R_{0}=20$
\end_inset

 light years and a time step of 
\begin_inset Formula $\frac{1}{250}\tau_{crunch}$
\end_inset

, we did a series of simulations where we varied the gravitational correction
 parameter in the interval 
\begin_inset Formula $\epsilon\in[0,$
\end_inset

0.15].
 According to equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:epsilon"

\end_inset

, the values are supposed to be independent of mass, but the masses used
 were a normal distribution with mean 
\begin_inset Formula $\mu=10$
\end_inset

 and 
\begin_inset Formula $\sigma=1$
\end_inset

 (both in solar masses).
\end_layout

\begin_layout Standard
The criteria for accepting an 
\begin_inset Formula $\epsilon$
\end_inset

 value are that the number of bound particles are as high as possible, while
 the total energy, at least for the bound particles, is as conserved as
 possible.
 In the process, we discovered that these criteria are actually mutually
 exclusive: The energy conservation improves if we eject many particles.
 Our interpretation of this result is that particles that are bound but
 close to being unbound will impact the energy bound conservation negatively:
 If these particles are actually ejected, the remaining particles' total
 energy is better conserved.
 Thus, we need to look at both criteria simultaneously when deciding on
 a value for 
\begin_inset Formula $\epsilon$
\end_inset

.
 Additionally, we want 
\begin_inset Formula $\epsilon$
\end_inset

 to be as close to 0 (and the Newtonian limit) as possible, so we get more
 realistic results.
\end_layout

\begin_layout Standard
Looking at (SOURCE), we see also that the number of ejected particles will
 fluctuate considerably between simulations with the same starting parameters.
 Ideally, we would run many simulations with the same epsilon value to eliminate
 statistical errors - this is something that could be looked at in a future
 study.
\end_layout

\begin_layout Paragraph
Particles ejection and equilibrium
\end_layout

\begin_layout Standard
As discussed in the theory part, the system seems to reach an equilibrium.
 We can see it happens around 
\begin_inset Formula $1\tau_{crunch}$
\end_inset

.
 And we know, after deriving the theoritical results, that it, in fact,
 happens after 
\begin_inset Formula $0.81\tau_{crunch}$
\end_inset

 (i.e.
 for circa 6,458 millions of years).
 
\end_layout

\begin_layout Standard
After this time, we can this on the following plots displaying the number
 of bound particles in regard to the time, that suddenly, the number of
 ejected particles blows up.
 And we can see, as expected, that without using the smoothing function,
 we lose a lot more of particles in just a few 
\begin_inset Formula $\tau_{crunch}$
\end_inset

.
 The results are stabilized when we add epsilon, and the quantity of lost
 particles decreased.
 
\end_layout

\begin_layout Standard
When we increase N, the number of initial particles, we increase the percentage
 of lost particles too.
 But we keep the total mass constant, which means that as N increases, the
 particles become lighter.
 Since the energies, kinetic and potential, are both a function of the mass
 of the processed particles, we can see that the quantity of lost energy
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename Screen/d-e/plot_for_100_Particles_Epsi_0.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Number of bound particles for N initial = 100 bodies, ε = 0
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename Screen/d-e/plot_for_200_Particles_Epsi_0.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Number of bound particles for N initial = 200 bodies, ε = 0
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Screen/d-e/plot_for_300_Particles_Epsi_0.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Number of bound particles for N initial = 300 bodies, ε = 0
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Without using the modified gravitational potential, the energy is clearly
 not conserved: a lot of particles are ejected out of the system.
 For these particles, the kinetic energy blows up, and the total energy
 of theses particles is positive.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename Screen/d-e/plot_for_100_Particles_Epsi_0_10.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Number of bound particles for N initial = 100, ε = 0.10005
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename Screen/d-e/plot_for_200_Particles_Epsi_0_071.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Number of bound particles for N initial = 200, ε = 0,071
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename Screen/d-e/plot_for_300_Particles_Epsi_0_06.jpeg
	scale 35

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Number of bound particles for N initial =300 bodies, ε = 0,06
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After adding the smoothing part in our gravitational potential, we can see
 that the quantity kinetic energy does not blow up anymore, and the quantity
 of energy lost is a lot smaller than before: this was expected, since we
 reduced the numerical instability by adding this ε factor in the calculation
 of our Newtonian force.
 Thus, the behavior of particles when they come closer to each other is
 more stable: we lose less particles than before.
\end_layout

\begin_layout Paragraph
Virial Theorem
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename Screen/f/Virial_Epsilon.jpg
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Ratio
\begin_inset Formula $\frac{\left\langle P\right\rangle }{\left\langle K\right\rangle }$
\end_inset

for different epsilons, N = 100
\end_layout

\end_inset


\end_layout

\end_inset

 
\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\noindent
\align right
\begin_inset Graphics
	filename Screen/f/Virial_N.jpg
	scale 45

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Ratio
\begin_inset Formula $\frac{\left\langle P\right\rangle }{\left\langle K\right\rangle }$
\end_inset

for different N, epsilon ≈ 0.03
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After running the system for a few 
\begin_inset Formula $\tau_{crunch}$
\end_inset

, we evaluate the kinetic and the potential energies for every particles
 of our bound system.
 What is displayed here is the value of the average kinetic energy, 
\begin_inset Formula $\left\langle K\right\rangle $
\end_inset

 , and the average of the potential energy,
\begin_inset Formula $\left\langle P\right\rangle $
\end_inset

, for our bound system.
 We can see that the virial theorem is met in the case where the smoothing
 function is used, with an 
\begin_inset Formula $\epsilon$
\end_inset

 of 
\begin_inset Formula $\sqrt{0,0225}$
\end_inset

, and is not met in our initial case (i.e.
 without using the smoothing function).
 The smoothing function helps us to take care of the numerical instability
 generated when two particles are too close.
 Indeed, with the standard gravitational potentiel, we lose too many particles.
 Thus, the introduction of ε solves this problem.
 
\end_layout

\begin_layout Standard
We took ε = 
\begin_inset Formula $\sqrt{0,0225}$
\end_inset

, which was a satisfying value for the respect of the total energy conservation.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
What we learned:
\end_layout

\begin_layout Itemize
?
\end_layout

\begin_layout Subsection
Critique
\end_layout

\begin_layout Itemize
?
\end_layout

\end_body
\end_document
